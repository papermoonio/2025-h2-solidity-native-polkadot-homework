# 重入 (Reentrancy) 漏洞演示 

## 目的
本作业旨在演示智能合约中“重入攻击”的工作原理、触发条件以及常见修复方法。注意：为了安全与道德考虑，本仓库仅包含教学性说明与非可执行伪代码，不包含可直接部署用于攻击的 exploit 合约。

## 漏洞描述（概念）
当合约在进行外部调用（例如将 Ether 转给某个地址）**之前**没有先更新合约内部关键状态（如用户余额），攻击者可以利用其回调（fallback/receive）再次进入该函数，从而重复提取资金。常见错误模式是：`外部调用 -> 状态更新`（应该是相反顺序）。

## 演示的脆弱点
关键行：`msg.sender.call{value: amount}("")` 在 `balances[msg.sender] -= amount` 之前执行，造成重入窗口。

## 攻击思路（高层、非可执行）
1. 攻击合约先向脆弱合约存入一笔资金。  
2. 攻击合约调用脆弱合约的 `withdraw`。  
3. 脆弱合约在减少余额之前把资金发回攻击合约，触发攻击合约回调。  
4. 回调中攻击合约再次调用 `withdraw`，重复提取。  
（此处省略 exploit 具体实现代码，仅做概念描述）

## 本地实验建议（仅限受控本地网络）
- 在 Hardhat 本地节点或 Ganache 上进行测试。  
- 使用单元测试框架模拟攻击合约的回调行为（仅在课堂/本地环境进行）。  
- **不要**把脆弱合约或攻击合约部署到公共测试网或主网。  

## 终端输出
```
💰 Dao before attack: 10 ETH
⚠️ Dao after attack: 0.XX ETH
🦹 Hacker balance: > 1 ETH
```
攻击成功 ✔_
Dao 资金被重入攻击循环提走。
## 修复建议
- 使用 Checks-Effects-Interactions 模式：先检查，先修改合约内部状态，最后才做外部调用。  
- 使用 pull pattern（让用户自行 withdraw，而不是合约主动 push）并记录可取余额。  
- 在关键函数上使用互斥锁（`nonReentrant` / `ReentrancyGuard`）。  
- 最小化外部调用并优先使用安全的库（OpenZeppelin 等）。

## 结论
重入漏洞易被忽视但后果严重。通过良好的编码习惯、单元测试以及使用成熟库可以大幅降低风险。