// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title LogicContract - 可升級合約模式的邏輯合約
 * @dev 這個合約包含業務邏輯，但不直接存儲狀態，狀態由代理合約通過 delegatecall 管理
 * 
 * 設計模式：可升級合約
 * 
 * 核心概念：
 * 1. 邏輯與狀態分離：此合約僅包含業務邏輯，實際狀態存儲在代理合約中
 * 2. 代理模式：通過 ProxyContract 的 delegatecall 執行此合約的代碼
 * 3. 可升級性：可以部署新版本的邏輯合約並更新代理合約指向
 *
 */
contract LogicContract {
    // ============================================
    // 存儲變量聲明
    // ============================================
    
    /**
     * @dev 重要：存儲布局必須與代理合約完全一致！
     * 這些變量的順序、類型和位置必須與 ProxyContract 中的前兩個變量完全相同。
     * 
     * 為什麼這很重要？
     * - 當代理合約通過 delegatecall 調用此合約時，它們共享相同的存儲布局
     * - 此合約中的 count 對應代理合約的 slot 0
     * - 此合約中的 owner 對應代理合約的 slot 1
     * - 任何不匹配都會導致數據損壞和嚴重安全問題
     * 
     * 升級規則：
     * 1. 永遠不要更改現有變量的順序
     * 2. 永遠不要更改現有變量的類型
     * 3. 只能在現有變量末尾添加新變量
     * 4. 新變量必須考慮與之前版本的兼容性
     */
    uint256 public count;  // 計數器狀態變量（slot 0）
    address public owner;  // 所有者地址狀態變量（slot 1）
    
    // ============================================
    // 事件定義
    // ============================================
    
    /**
     * @dev 當計數器增加時觸發的事件
     * @param caller 調用 increment() 函數的地址
     * @param newCount 增加後的新計數值
     * 
     * 事件作用：
     * 1. 提供區塊鏈上的可追溯性
     * 2. 允許 DApp 前端監聽狀態變化
     * 3. 幫助調試和監控合約使用情況
     * 
     * 注意：由於此合約通過 delegatecall 執行，事件會在代理合約的上下文中發出
     */
    event Incremented(address indexed caller, uint256 newCount);
    
    // ============================================
    // 初始化函數
    // ============================================
    
    /**
     * @dev 初始化函數（用於代理合約的設置）
     * 
     * 功能：
     * 1. 設置合約所有者
     * 2. 初始化計數器為 0
     * 
     * 安全機制：
     * - 使用 require(owner == address(0)) 防止重複初始化
     * - 只能在合約部署後且 owner 為零地址時調用一次
     * - 這是一種防止重放攻擊的保護措施
     * 
     * 調用方式：
     * 此函數必須通過代理合約的 delegatecall 調用，這樣：
     * - owner 會被設置在代理合約的存儲中
     * - count 會被設置在代理合約的存儲中
     * - 此合約本身的存儲保持不變（永遠為初始狀態）
     * 
     * 技術細節：
     * 當 ProxyContract 在建構子中調用此函數時：
     * 1. 代理合約執行 delegatecall 到這個函數
     * 2. 這個函數的代碼在代理合約的上下文中執行
     * 3. 所以設置的 owner 和 count 實際上是代理合約的變量
     * 4. LogicContract 自己的 owner 和 count 保持為 0
     */
    function initialize() external {
        // 檢查是否已經初始化（owner 應該為零地址）
        // 這確保初始化只能執行一次，防止所有者被惡意重置
        require(owner == address(0), "Already initialized");
        
        // 設置所有者為調用者（通常是 ProxyContract 的部署者）
        owner = msg.sender;
        
        // 初始化計數器為 0
        count = 0;
        
        // 注意：這裡沒有發出事件，因為初始化通常不需要記錄
        // 但實際生產環境可能需要記錄 Initialized 事件
    }
    
    // ============================================
    // 業務邏輯函數
    // ============================================
    
    /**
     * @dev 增加計數器的函數
     * @return 增加後的新計數值
     * 
     * 功能：
     * 1. 檢查調用者是否為所有者
     * 2. 將計數器增加 1
     * 3. 發出 Incremented 事件
     * 4. 返回新的計數值
     * 
     * 權限控制：
     * - 只有 owner 可以調用此函數
     * - 這是一個基本的訪問控制示例
     * - 生產環境可能使用更複雜的權限系統（如角色管理）
     * 
     * 狀態變化：
     * - 修改代理合約中的 count 變量（通過 delegatecall）
     * - 此合約自身的 count 保持不變
     * 
     * 事件觸發：
     * - 事件會在代理合約的上下文中發出
     * - 事件的日志會關聯到代理合約的交易
     * - 前端可以監聽代理合約地址的事件
     */
    function increment() external returns (uint256) {
        // 訪問控制：只有所有者可以增加計數
        require(msg.sender == owner, "Only owner can increment");
        
        // 增加計數器
        count += 1;
        
        // 發出事件，記錄調用者和新的計數值
        emit Incremented(msg.sender, count);
        
        // 返回新的計數值
        return count;
    }
    
    // ============================================
    // 視圖函數（只讀函數）
    // ============================================
    
    /**
     * @dev 獲取當前計數值
     * @return 當前的計數值
     * 
     * 函數特性：
     * - view 修飾符表示此函數不修改狀態
     * - 不消耗 gas（當從外部調用時）
     * - 可以從任何地址調用，沒有權限限制
     * 
     * 返回值：
     * - 當通過代理合約的 delegatecall 調用時：返回代理合約的 count
     * - 當直接調用此合約時：返回此合約自身的 count（通常為 0）
     * 
     * 使用場景：
     * 1. 前端顯示當前計數
     * 2. 其他合約查詢狀態
     * 3. 測試和驗證
     */
    function getCount() external view returns (uint256) {
        return count;
    }
}
